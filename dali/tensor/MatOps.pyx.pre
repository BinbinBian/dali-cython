pyp
from preprocessor_utils import (
    typed_expression,
    typed_expression_args,
    typed_expression_args_with_types,
    typed_expression_list,
    type_repeat,
    type_repeat_with_types,
)

WITHOUT_INT = ["float", "double"]
ypy


cdef extern from "dali/tensor/MatOps.h" nogil:
    cdef cppclass CMatOps "MatOps" [T]:
        ### OTHER ###
        @staticmethod
        CMat[T] fill(CMat[T] to_fill, T filler)

        @staticmethod
        CMat[T] consider_constant(CMat[T])

        @staticmethod
        bint equals(CMat[T], CMat[T])

        @staticmethod
        bint allclose(CMat[T], CMat[T], double tol)

        @staticmethod
        bint grad_allclose(CMat[T], CMat[T], double tol)

        @staticmethod
        vector[int] argsort(CMat[T])

        @staticmethod
        vector[size_t] argsort(const vector[CMat[T]]&)

        @staticmethod
        int argmax(const CMat[T]&) except +

        @staticmethod
        int argmin(const CMat[T]&) except +

        @staticmethod
        vector[int] argmax_axis "argmax" (const CMat[T]&, int dimension)

        @staticmethod
        vector[int] argmin_axis "argmin" (const CMat[T]&, int dimension)

        @staticmethod
        int argmax_slice(const CMat[T]&, int lower, int upper)

        @staticmethod
        int argmin_slice(const CMat[T]&, int lower, int upper)

        @staticmethod
        void copy(CMat[T]* dest, const CMat[T]& source)

        @staticmethod
        void copy_grad(CMat[T]* dest, const CMat[T]& source)

        ### REDUCERS ###
        @staticmethod
        CMat[T] L2_norm(CMat[T])

        @staticmethod
        CMat[T] sum(CMat[T])

        @staticmethod
        CMat[T] mean(CMat[T])

        ### RESHAPING ###

        @staticmethod
        CMat[T] hstack(CMat[T], CMat[T])

        @staticmethod
        CMat[T] hstack_vec "hstack" (const vector[CMat[T]]&)

        @staticmethod
        CMat[T] vstack(CMat[T], CMat[T])

        @staticmethod
        CMat[T] vstack_vec "vstack"(const vector[CMat[T]]&)

        @staticmethod
        CMat[T] transpose(CMat[T])

        @staticmethod
        CMat[T] rows_pluck(CMat[T], CMat[int])

        # requires Indexing::Index
        # @staticmethod
        # CMat[T] rows_pluck

        # @staticmethod
        # CMat[T] rows_cols_pluck

        @staticmethod
        CMat[T] row_pluck(CMat[T], int)

        @staticmethod
        CMat[T] col_pluck(CMat[T], int)

        @staticmethod
        void resize(CMat[T]& mat, unsigned int rows, unsigned int cols)

        ### SOLVER_UPDATES ###
        @staticmethod
        void clip_and_regularize(CMat[T] param, T clipval, T regc)

        @staticmethod
        void sgd_update(CMat[T] param, T step_size)

        # requires TensorInternal
        # @staticmethod
        # void adagrad_update(CMat[T] param, T step_size)

        # @staticmethod
        # void rmsprop_update

        # @staticmethod
        # void adadelta_update

        # @staticmethod
        # void adam_update

        ### ELEMWISE ###
        @staticmethod
        CMat[T] add(CMat[T], T)

        @staticmethod
        CMat[T] sub_broadcast_reversed(CMat[T], T)

        @staticmethod
        CMat[T] eltmul(CMat[T], T)

        @staticmethod
        CMat[T] eltdivide(CMat[T], T)

        @staticmethod
        CMat[T] max(CMat[T], T)

        @staticmethod
        CMat[T] square(CMat[T])

        @staticmethod
        CMat[T] log(CMat[T])

        @staticmethod
        CMat[T] exp(CMat[T])

        @staticmethod
        CMat[T] sigmoid(CMat[T])

        @staticmethod
        CMat[T] steep_sigmoid(CMat[T], T aggressiveness)

        @staticmethod
        CMat[T] tanh(CMat[T])

        @staticmethod
        CMat[T] relu(CMat[T])

        @staticmethod
        CMat[T] abs(CMat[T])

        @staticmethod
        CMat[T] pow(CMat[T], T power)

        @staticmethod
        CMat[T] sqrt(CMat[T])

        @staticmethod
        CMat[T] elt_inv(CMat[T])

        ### DROPOUT ###

        @staticmethod
        CMat[T] dropout(CMat[T], T drop_prob)

        @staticmethod
        CMat[T] dropout_normalized(CMat[T], T drop_prob)

        @staticmethod
        CMat[T] fast_dropout(CMat[T])

        @staticmethod
        vector[CMat[T]] dropout(const vector[CMat[T]]&, T drop_prob)

        @staticmethod
        vector[CMat[T]] dropout_normalized(const vector[CMat[T]]&, T drop_prob)

        @staticmethod
        vector[CMat[T]] fast_dropout(const vector[CMat[T]]&)

        ### COST ###

        @staticmethod
        CMat[T] binary_cross_entropy(CMat[T], T target) except +

        @staticmethod
        CMat[T] sigmoid_binary_cross_entropy(CMat[T], T target) except +

        @staticmethod
        CMat[T] softmax_colwise(CMat[T], T temperature) except +

        @staticmethod
        CMat[T] softmax_rowwise(CMat[T], T temperature) except +

        @staticmethod
        CMat[T] softmax_no_grad_colwise(CMat[T], T temperature) except +

        @staticmethod
        CMat[T] softmax_no_grad_rowwise(CMat[T], T temperature) except +

        @staticmethod
        CMat[T] margin_loss_colwise(CMat[T], unsigned int answer_idx, T margin) except +

        @staticmethod
        CMat[T] margin_loss_rowwise(CMat[T], unsigned int answer_idx, T margin) except +


        @staticmethod
        CMat[T] softmax_cross_entropy_rowwise(CMat[T], unsigned int answer_idx) except +

        @staticmethod
        CMat[T] softmax_cross_entropy_colwise(CMat[T], unsigned int answer_idx) except +

cdef class MatOps:
    @staticmethod
    def fill(Mat mat, filler):
        pypinline type_repeat(pyp,
        cdef TYPE_NAME TYPED(filler)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            TYPED(filler) = filler
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].fill(DEREF_MAT(mat), TYPED(filler))
            return WRAP_MAT(TYPED(out))
        ypy


    @staticmethod
    def consider_constant(Mat mat):
        pypinline typed_expression_args(pyp, ["mat"],
            return WRAP_MAT(CMatOps[TYPE_NAME].consider_constant(DEREF_MAT(mat)))
        ypy

    @staticmethod
    def equals(Mat a, Mat b):
        cdef bint out
        pypinline typed_expression_args(pyp, ["a", "b"],
            with nogil:
                out = CMatOps[TYPE_NAME].equals(DEREF_MAT(a), DEREF_MAT(b))
            return out
        ypy

    @staticmethod
    def allclose(Mat a, Mat b, float tol = 1e-6):
        cdef bint out

        pypinline typed_expression_args(pyp, ["a", "b"],
            with nogil:
                out = CMatOps[TYPE_NAME].allclose(DEREF_MAT(a), DEREF_MAT(b), tol)
            return out
        ypy

    @staticmethod
    def grad_allclose(Mat a, Mat b, float tol = 1e-6):
        cdef bint out
        pypinline typed_expression_args(pyp, ["a", "b"],
            with nogil:
                out = CMatOps[TYPE_NAME].grad_allclose(DEREF_MAT(a), DEREF_MAT(b), tol)
            return out
        ypy

    @staticmethod
    def argsort(Mat mat):
        cdef vector[int] out
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                out = CMatOps[TYPE_NAME].argsort(DEREF_MAT(mat))
            return out
        ypy

    @staticmethod
    def argmax(Mat mat, axis=None):
        cdef int         out_int
        cdef vector[int] out_vector
        cdef int axis_int
        pypinline typed_expression_args(pyp, ["mat"],
            if axis is not None:
                axis_int = axis
                with nogil:
                    out_vector = CMatOps[TYPE_NAME].argmax_axis(DEREF_MAT(mat), axis_int)
                return out_vector
            else:
                with nogil:
                    out_int = CMatOps[TYPE_NAME].argmax(DEREF_MAT(mat))
                return out_int
        ypy

    @staticmethod
    def argmin(Mat mat, axis=None):
        cdef int         out_int
        cdef vector[int] out_vector
        cdef int axis_int
        pypinline typed_expression_args(pyp, ["mat"],
            if axis is not None:
                axis_int = axis
                with nogil:
                    out_vector = CMatOps[TYPE_NAME].argmin_axis(DEREF_MAT(mat), axis_int)
                return out_vector
            else:
                with nogil:
                    out_int = CMatOps[TYPE_NAME].argmin(DEREF_MAT(mat))
                return out_int
        ypy

    @staticmethod
    def argmax_slice(Mat mat, int lower, int upper):
        cdef int out
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                out = CMatOps[TYPE_NAME].argmax_slice(DEREF_MAT(mat), lower, upper)
            return out
        ypy

    @staticmethod
    def argmin_slice(Mat mat, int lower, int upper):
        cdef int out
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                out = CMatOps[TYPE_NAME].argmin_slice(DEREF_MAT(mat), lower, upper)
            return out
        ypy


    @staticmethod
    def copy(Mat destination, Mat source):
        pypinline typed_expression_args(pyp, ["destination", "source"],
            with nogil:
                CMatOps[TYPE_NAME].copy(PTR_MAT(destination), DEREF_MAT(source))
        ypy

    @staticmethod
    def copy_grad(Mat destination, Mat source):
        pypinline typed_expression_args(pyp, ["destination", "source"],
            with nogil:
                CMatOps[TYPE_NAME].copy_grad(PTR_MAT(destination), DEREF_MAT(source))
        ypy

    # ### REDUCERS ###
    @staticmethod
    def L2_norm(Mat mat):
        pypinline type_repeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].L2_norm(DEREF_MAT(mat))
            return WRAP_MAT(TYPED(out))
        ypy

    @staticmethod
    def mean(Mat mat):
        pypinline type_repeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].mean(DEREF_MAT(mat))
            return WRAP_MAT(TYPED(out))
        ypy

    @staticmethod
    def sum(Mat mat):
        pypinline type_repeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].sum(DEREF_MAT(mat))
            return WRAP_MAT(TYPED(out))
        ypy

    ### RESHAPING ###

    @staticmethod
    def resize(Mat mat,  unsigned int rows, unsigned int cols):
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                CMatOps[TYPE_NAME].resize(DEREF_MAT(mat), rows, cols)
        ypy


    @staticmethod
    def hstack(arg1, arg2=None):
        pypinline type_repeat(pyp,
        cdef vector[CMat[TYPE_NAME]] TYPED(input_matrices)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        cdef Mat left
        cdef Mat right
        cdef common_dtype
        if arg2 is None:
            pypinline typed_expression_list(pyp, "arg1", "Mat",
                TYPED(input_matrices) = TYPED(mats_to_vec)(arg1)
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].hstack_vec(TYPED(input_matrices))
                return WRAP_MAT(TYPED(out))
            ypy
        else:
            left  = <Mat> arg1
            right = <Mat> arg2
            pypinline typed_expression_args(pyp, ["left", "right"],
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].hstack(DEREF_MAT(left), DEREF_MAT(right))
                return WRAP_MAT(TYPED(out))
            ypy

    @staticmethod
    def vstack(arg1, arg2=None):
        pypinline type_repeat(pyp,
        cdef vector[CMat[TYPE_NAME]] TYPED(input_matrices)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        cdef Mat top
        cdef Mat bottom
        cdef common_dtype
        if arg2 is None:
            pypinline typed_expression_list(pyp, "arg1", "Mat",
                TYPED(input_matrices) = TYPED(mats_to_vec)(arg1)
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].vstack_vec(TYPED(input_matrices))
                return WRAP_MAT(TYPED(out))
            ypy
        else:
            top    = <Mat> arg1
            bottom = <Mat> arg2
            pypinline typed_expression_args(pyp, ["top", "bottom"],
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].vstack(DEREF_MAT(top), DEREF_MAT(bottom))
                return WRAP_MAT(TYPED(out))
            ypy

    @staticmethod
    def transpose(Mat mat):
        pypinline type_repeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy

        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].transpose(DEREF_MAT(mat))
            return WRAP_MAT(TYPED(out))
        ypy

    # ### UPDATES ###
    @staticmethod
    def sgd_update(Mat mat, float step_size):
        pypinline typed_expression_args_with_types(pyp, WITHOUT_INT, ["mat"],
            with nogil:
                CMatOps[TYPE_NAME].sgd_update(DEREF_MAT(mat), step_size)
        ypy

    @staticmethod
    def clip_and_regularize(Mat mat, float clipval = 5.0, float regc = 1e-6):
        pypinline typed_expression_args_with_types(pyp, WITHOUT_INT, ["mat"],
            with nogil:
                CMatOps[TYPE_NAME].clip_and_regularize(DEREF_MAT(mat), clipval, regc)
        ypy

    ### ELEMWISE ###

pyprepeat OP_NAME in ['add', 'sub_broadcast_reversed', 'eltmul', 'eltdivide', 'max', 'dropout', 'dropout_normalized', 'pow', 'binary_cross_entropy', 'sigmoid_binary_cross_entropy']
    @staticmethod
    def OP_NAME(Mat mat, val):
        pypinline type_repeat(pyp,
        cdef TYPE_NAME TYPED(val)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            TYPED(val) = val
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].OP_NAME(DEREF_MAT(mat), TYPED(val))
            return WRAP_MAT(TYPED(out))
        ypy
ypyrepeat


pyprepeat OP_NAME in ['square', 'log', 'exp', 'sigmoid', 'tanh','relu','abs','sqrt', 'elt_inv', 'fast_dropout']
    @staticmethod
    def OP_NAME(Mat mat):
        pypinline type_repeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].OP_NAME(DEREF_MAT(mat))
            return WRAP_MAT(TYPED(out))
        ypy
ypyrepeat


    @staticmethod
    def dropout(Mat mat, drop_prob, normalized=True):
        pypinline type_repeat(pyp,
        cdef TYPE_NAME TYPED(drop_prob)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            TYPED(drop_prob) = drop_prob
            if normalized:
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].dropout_normalized(DEREF_MAT(mat), TYPED(drop_prob))
                return WRAP_MAT(TYPED(out))
            else:
                with nogil:
                    TYPED(out) = CMatOps[TYPE_NAME].dropout(DEREF_MAT(mat), TYPED(drop_prob))
                return WRAP_MAT(TYPED(out))
        ypy


    @staticmethod
    def steep_sigmoid(Mat mat, aggressiveness =  3.75):
        pypinline type_repeat(pyp,
        cdef TYPE_NAME TYPED(aggressiveness)
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        pypinline typed_expression_args(pyp, ["mat"],
            TYPED(aggressiveness) = aggressiveness
            with nogil:
                TYPED(out) = CMatOps[TYPE_NAME].steep_sigmoid(DEREF_MAT(mat), TYPED(aggressiveness))
            return WRAP_MAT(TYPED(out))
        ypy

    @staticmethod
    def softmax_cross_entropy(Mat mat, int answer_idx, int axis=1):
        pypinline type_repeat_with_types(pyp, WITHOUT_INT,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        if axis != 0 and axis != 1:
            raise ValueError("axis must be 0 (columnwise) or 1 (rowwise)")
        pypinline typed_expression_args_with_types(pyp, WITHOUT_INT, ["mat"],
            with nogil:
                if axis == 0:
                    TYPED(out) = CMatOps[TYPE_NAME].softmax_cross_entropy_colwise(DEREF_MAT(mat), answer_idx)
                elif axis == 1:
                    TYPED(out) = CMatOps[TYPE_NAME].softmax_cross_entropy_rowwise(DEREF_MAT(mat), answer_idx)

            return WRAP_MAT(TYPED(out))
        ypy


    @staticmethod
    def margin_loss(Mat mat, int answer_idx, int axis = 1, float margin = 0.1):
        pypinline type_repeat_with_types(pyp, WITHOUT_INT,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        if axis != 0 and axis != 1:
            raise ValueError("axis must be 0 (columnwise) or 1 (rowwise)")
        pypinline typed_expression_args_with_types(pyp, WITHOUT_INT, ["mat"],
            with nogil:
                if axis == 0:
                    TYPED(out) = CMatOps[TYPE_NAME].margin_loss_colwise(DEREF_MAT(mat), answer_idx, margin)
                elif axis == 1:
                    TYPED(out) = CMatOps[TYPE_NAME].margin_loss_rowwise(DEREF_MAT(mat), answer_idx, margin)

            return WRAP_MAT(TYPED(out))
        ypy



pyprepeat SOFTMAX_OP_NAME in ['softmax', 'softmax_no_grad']

    @staticmethod
    def SOFTMAX_OP_NAME(Mat mat, float temperature = 1.0, int axis = 1):
        pypinline type_repeat_with_types(pyp, WITHOUT_INT,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy
        if axis != 0 and axis != 1:
            raise ValueError("axis must be 0 (columnwise) or 1 (rowwise)")
        pypinline typed_expression_args_with_types(pyp, WITHOUT_INT, ["mat"],
            with nogil:
                if axis == 0:
                    TYPED(out) = CMatOps[TYPE_NAME].SOFTMAX_OP_NAME_colwise(DEREF_MAT(mat), temperature)
                elif axis == 1:
                    TYPED(out) = CMatOps[TYPE_NAME].SOFTMAX_OP_NAME_rowwise(DEREF_MAT(mat), temperature)

            return WRAP_MAT(TYPED(out))
        ypy

ypyrepeat
