pyp
from preprocessor_utils import (
    typed_expression,
    typed_fexpression,
    typed_expression_args,
    typed_fexpression_args,
    typed_expression_args_with_types,
    typed_expression_list,
    type_repeat,
    type_frepeat,
    type_repeat_with_types,
)
ypy


cdef extern from "dali/layers/Layers.h" nogil:
    cdef cppclass CLayer "Layer" [T]:
        int hidden_size
        int input_size
        CMat[T] W
        CMat[T] b

        vector[CMat[T]] parameters() const
        # constructors
        CLayer()
        CLayer(int input_size, int hidden_size)
        CLayer(const CLayer& other, bint copy_w, bint copy_dw)

        CMat[T] activate(CMat[T]) except +
        CLayer[T] shallow_copy() const

    cdef cppclass CRNN "RNN" [T] nogil:
        int input_size
        int hidden_size
        int output_size

        CMat[T] Wx
        CMat[T] Wh
        CMat[T] b

        CRNN()
        CRNN(int input_size, int hidden_size)
        CRNN(int input_size, int hidden_size, int output_size)
        CRNN(CRNN[T]&, bool, bool)
        CMat[T] activate(CMat[T] input_vector, CMat[T] prev_hidden) except +
        CRNN[T] shallow_copy() const
        vector[CMat[T]] parameters() const

    cdef cppclass CStackedInputLayer "StackedInputLayer" [T] nogil:
        vector[int] input_sizes() const
        int hidden_size
        vector[CMat[T]] matrices
        CMat[T] b

        vector[CMat[T]] parameters() const
        CStackedInputLayer()
        CStackedInputLayer(vector[int] input_sizes, int output_size)
        CStackedInputLayer(const CStackedInputLayer& other, bint copy_w, bint copy_dw)

        CMat[T] activate(const vector[CMat[T]]&) except +
        CMat[T] activate(CMat[T]) except +
        CMat[T] activate(CMat[T], const vector[CMat[T]]&) except +

        CStackedInputLayer[T] shallow_copy() const


cdef class Layer:
    cdef void* layerinternal
    cdef np.NPY_TYPES dtypeinternal

    property dtype:
        def __get__(Mat self):
            return np.PyArray_DescrFromType(self.dtypeinternal)



pyprepeat PROPERTY_NAME in ['input_size', 'hidden_size',]
    property PROPERTY_NAME:
        def __get__(Layer self):
            pypinline typed_fexpression_args(pyp, ["self"],
                return DEREF_LAYER(self).PROPERTY_NAME
            ypy
ypyrepeat

pyprepeat PARAM_NAME in ['W', 'b']

    property PARAM_NAME:
        def __get__(Layer self):
            pypinline typed_fexpression_args(pyp, ["self"],
                return WRAP_MAT(DEREF_LAYER(self).PARAM_NAME)
            ypy
ypyrepeat

    def __cinit__(Layer self, int input_size, int hidden_size, dtype=np.float32):
        self.layerinternal = NULL
        self.dtypeinternal = np.NPY_NOTYPE


        self.dtypeinternal = np.dtype(dtype).num
        pypinline typed_fexpression_args(pyp, ["self"],
            self.layerinternal = new CLayer[TYPE_NAME](input_size, hidden_size)
        ypy

    def __dealloc__(Layer self):
        self.free_internal()

    def free_internal(Layer self):
        pypinline type_frepeat(pyp,
        cdef CLayer[TYPE_NAME]* TYPED(ptr_internal)
        ypy
        if self.layerinternal != NULL:
            pypinline typed_fexpression_args(pyp, ["self"],
                TYPED(ptr_internal) = PTR_LAYER(self)
                with nogil:
                    del TYPED(ptr_internal)
            ypy
            self.layerinternal = NULL

    def activate(Layer self, Mat input_vector):
        pypinline type_frepeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy

        pypinline typed_expression_args(pyp, ["self"],
            with nogil:
                TYPED(out) = DEREF_LAYER(self).activate(DEREF_MAT(input_vector))
            return WRAP_MAT(TYPED(out))
        ypy


    def shallow_copy(Layer self):
        cdef Layer copy = Layer(0,0)
        copy.free_internal()
        pypinline typed_fexpression_args(pyp, ["self"],
            copy.layerinternal = new CLayer[TYPE_NAME](DEREF_LAYER(self), False, True)
        ypy
        return copy

    def parameters(Layer self):
        params = []
        pypinline type_frepeat(pyp,
        cdef vector[CMat[TYPE_NAME]] TYPED(params_mat)
        cdef CMat[TYPE_NAME]         TYPED(param)
        ypy
        pypinline typed_fexpression_args(pyp, ["self"],
            TYPED(params_mat) = DEREF_LAYER(self).parameters()

            for TYPED(param) in TYPED(params_mat):
                params.append(WRAP_MAT(TYPED(param)))
        ypy
        return params

    def __setstate__(Layer self, state):
        for param, saved_param in zip(self.parameters(), state["parameters"]):
            param.w = saved_param.w
        self.dtypeinternal = state["dtype"].num

    def __getstate__(Layer self):
        return {
            "parameters" : self.parameters(),
            "dtype" : self.dtype
        }

    def __reduce__(Layer self):
        return (
            self.__class__,
            (
                self.input_size,
                self.hidden_size,
            ), self.__getstate__(),
        )

    def __str__(self):
        return "<Layer in=%d, hidden=%d>" % (self.input_size, self.hidden_size)

    def __repr__(Layer self):
        return str(self)

pypinline type_repeat(pyp,
cdef inline Layer TYPED(WrapLayer)(const CLayer[TYPE_NAME]& internal):
    cdef Layer output = Layer(0,0)
    output.free_internal()
    output.layerinternal = new CLayer[TYPE_NAME](internal, False, False)
    output.dtypeinternal = TYPE_NPYINTERNAL
    return output
ypy


cdef class RNN:
    cdef void*        layerinternal
    cdef np.NPY_TYPES dtypeinternal

    property dtype:
        def __get__(Mat self):
            return np.PyArray_DescrFromType(self.dtypeinternal)

pyprepeat PROPERTY_NAME in ['input_size', 'hidden_size', 'output_size']
    property PROPERTY_NAME:
        def __get__(RNN self):
            pypinline typed_fexpression_args(pyp, ["self"],
                return DEREF_RNN(self).PROPERTY_NAME
            ypy
ypyrepeat

pyprepeat PARAM_NAME in ['Wx', 'Wh', 'b']

    property PARAM_NAME:
        def __get__(RNN self):
            pypinline typed_fexpression_args(pyp, ["self"],
                return WRAP_MAT(DEREF_RNN(self).PARAM_NAME)
            ypy
ypyrepeat


    def __cinit__(self, int input_size, int hidden_size, output_size = None, dtype=np.float32):
        self.layerinternal = NULL
        self.dtypeinternal = np.NPY_NOTYPE

        if output_size is None:
            output_size = hidden_size
        assert(input_size > -1 and hidden_size > -1 and output_size > -1), "Only positive dimensions may be used."
        cdef int out_size = output_size

        self.dtypeinternal = np.dtype(dtype).num

        pypinline typed_fexpression_args(pyp, ["<RNN>self"],
            self.layerinternal = new CRNN[TYPE_NAME](input_size, hidden_size, out_size)
        ypy

    def __dealloc__(RNN self):
        self.free_internal()

    def free_internal(RNN self):
        pypinline type_frepeat(pyp,
        cdef CRNN[TYPE_NAME]* TYPED(ptr_internal)
        ypy
        if self.layerinternal != NULL:
            pypinline typed_fexpression_args(pyp, ["self"],
                TYPED(ptr_internal) = PTR_RNN(self)
                with nogil:
                    del TYPED(ptr_internal)
            ypy
            self.layerinternal = NULL



    def __setstate__(RNN self, state):
        for param, saved_param in zip(self.parameters(), state["parameters"]):
            param.w = saved_param.w
        self.dtypeinternal = state["dtype"].num


    def __getstate__(self):
        return {
            "parameters" : self.parameters(),
            "dtype" : self.dtype
        }

    def __reduce__(self):
        return (
            self.__class__,
            (
                self.input_size,
                self.hidden_size,
                self.output_size
            ), self.__getstate__(),
        )


    def activate(RNN self, Mat input_vector,  Mat prev_hidden):
        pypinline type_frepeat(pyp,
        cdef CMat[TYPE_NAME] TYPED(out)
        ypy

        pypinline typed_fexpression_args(pyp, ["self"],
            with nogil:
                TYPED(out) = DEREF_RNN(self).activate(DEREF_MAT(input_vector), DEREF_MAT(prev_hidden))
            return WRAP_MAT(TYPED(out))
        ypy


    def shallow_copy(RNN self):
        cdef RNN copy = RNN(0,0)
        copy.free_internal()
        pypinline typed_fexpression_args(pyp, ["self"],
            copy.layerinternal = new CRNN[TYPE_NAME](DEREF_RNN(self), False, True)
        ypy
        return copy

    def parameters(RNN self):
        params = []
        pypinline type_frepeat(pyp,
        cdef vector[CMat[TYPE_NAME]] TYPED(params_mat)
        cdef CMat[TYPE_NAME]         TYPED(param)
        ypy
        pypinline typed_fexpression_args(pyp, ["self"],
            TYPED(params_mat) = DEREF_RNN(self).parameters()

            for TYPED(param) in TYPED(params_mat):
                params.append(WRAP_MAT(TYPED(param)))
        ypy
        return params


    def __str__(self):
        return "<RNN in=%d, hidden=%d out=%d>" % (self.input_size, self.hidden_size, self.output_size)

    def __repr__(Layer self):
        return str(self)


"""
cdef class StackedInputLayer:
    cdef CStackedInputLayer[dtype] layerinternal
    cdef np.NPY_TYPES dtypeinternal

    property dtype:
        def __get__(Mat self):
            return np.PyArray_DescrFromType(self.dtypeinternal)

    property input_sizes:
        def __get__(self):
            return self.layerinternal.input_sizes()

    property matrices:
        def __get__(self):
            matrices = []
            for param in self.layerinternal.matrices:
                matrices.append(WrapMat(param))
            return matrices

    property b:
        def __get__(self):
            return WrapMat(self.layerinternal.b)

    property hidden_size:
        def __get__(self):
            return self.layerinternal.hidden_size

    def __cinit__(self, list input_sizes, int hidden_size):
        self.layerinternal = NULL
        self.dtypeinternal = np.NPY_NOTYPE

        self.layerinternal = CStackedInputLayer[dtype](input_sizes, hidden_size)

    def __setstate__(GRU self, state):
        for param, saved_param in zip(self.parameters(), state["parameters"]):
            param.w = saved_param.w

    def __getstate__(self):
        return {
            "parameters" : self.parameters()
        }

    def __reduce__(self):
        return (
            self.__class__,
            (
                self.input_sizes,
                self.layerinternal.hidden_size
            ), self.__getstate__(),
        )

    def activate(self, inputs):
        cdef Mat output = Mat(0,0)
        if type(inputs) is Mat:
            output.matinternal = self.layerinternal.activate((<Mat>inputs).matinternal)
            return output
        cdef vector[CMat[dtype]] mat_vec
        if type(inputs) is list:
            for mat in inputs:
                mat_vec.push_back((<Mat>mat).matinternal)
            output.matinternal = self.layerinternal.activate(mat_vec)
            return output
        raise TypeError("activate takes a list of Mat or single Mat as input.")

    def shallow_copy(self):
        cdef StackedInputLayer copy = StackedInputLayer([],0)
        copy.layerinternal = self.layerinternal.shallow_copy()
        return copy

    def parameters(self):
        params = []
        cdef vector[CMat[dtype]] params_mat = self.layerinternal.parameters()
        for param in params_mat:
            params.append(WrapMat(param))
        return params

    def __str__(self):
        return "<StackedInputLayer in=%s, out=%d>" % (str(self.input_sizes), self.hidden_size)

    def __repr__(StackedInputLayer self):
        return str(self)

cdef inline StackedInputLayer WrapStackedInputLayer(const CStackedInputLayer[dtype]& internal):
    cdef StackedInputLayer output = StackedInputLayer([0],0)
    output.layerinternal = internal
    return output
"""
